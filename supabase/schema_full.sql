-- Ghost Secure full schema (Supabase + Symfony API/WS)
-- Safe to run on an empty database.
-- Also safe to re-run (idempotent as much as possible).

-- 1) Core users/conversations/messages
create table if not exists public.app_user (
  id varchar(36) primary key,
  public_key text not null,
  secret_hash varchar(255),
  created_at timestamp without time zone not null default now(),
  ecdh_public_key text,
  identity_key text,
  signed_prekey text,
  signed_prekey_signature text,
  registration_id integer
);

create table if not exists public.conversation (
  id varchar(36) primary key,
  created_at timestamp without time zone not null default now(),
  kind varchar(20) not null default 'direct',
  title varchar(255)
);

create table if not exists public.conversation_member (
  id bigint generated by default as identity primary key,
  conversation_id varchar(36) not null references public.conversation(id) on delete cascade,
  user_id varchar(36) not null references public.app_user(id) on delete cascade,
  unique (conversation_id, user_id)
);

create index if not exists idx_cm_conversation on public.conversation_member(conversation_id);
create index if not exists idx_cm_user on public.conversation_member(user_id);

create table if not exists public.message (
  id varchar(36) primary key,
  conversation_id varchar(36) not null references public.conversation(id) on delete cascade,
  sender_id varchar(36) references public.app_user(id) on delete set null,
  ciphertext text not null,
  iv text not null,
  wrapped_keys jsonb not null,
  created_at timestamp without time zone not null default now(),
  expires_at timestamp without time zone null,
  ephemeral_public_key text,
  ratchet_header text
);

create index if not exists idx_msg_conv_created on public.message(conversation_id, created_at);

-- 2) Backend auth sessions (required by Symfony API + WS token validation)
create table if not exists public.user_session (
  id bigint generated by default as identity primary key,
  user_id varchar(36) not null references public.app_user(id) on delete cascade,
  token_hash varchar(128) not null,
  created_at timestamp without time zone not null default now(),
  expires_at timestamp without time zone not null
);

create unique index if not exists uniq_session_token on public.user_session(token_hash);
create index if not exists idx_session_user on public.user_session(user_id);

-- 3) One-time pre-keys (Signal Protocol)
create table if not exists public.one_time_prekey (
  id uuid primary key default gen_random_uuid(),
  user_id varchar(36) not null references public.app_user(id) on delete cascade,
  key_id integer not null,
  public_key text not null,
  created_at timestamp with time zone not null default now(),
  unique(user_id, key_id)
);

create index if not exists idx_otpk_user on public.one_time_prekey(user_id);

-- 4) Friend requests + call signaling
create table if not exists public.friend_request (
  id varchar(36) primary key,
  requester_id varchar(36) not null references public.app_user(id) on delete cascade,
  target_user_id varchar(36) not null references public.app_user(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'rejected')),
  created_at timestamp without time zone not null default now()
);

create index if not exists idx_fr_target_status on public.friend_request(target_user_id, status, created_at desc);
create index if not exists idx_fr_requester_status on public.friend_request(requester_id, status, created_at desc);
create unique index if not exists uniq_fr_pending_pair
  on public.friend_request(requester_id, target_user_id)
  where status = 'pending';

create table if not exists public.call_invite (
  id varchar(36) primary key,
  call_id varchar(36) not null unique,
  from_user_id varchar(36) not null references public.app_user(id) on delete cascade,
  target_user_id varchar(36) not null references public.app_user(id) on delete cascade,
  offer_sdp jsonb not null,
  answer_sdp jsonb null,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'rejected', 'ended')),
  created_at timestamp without time zone not null default now(),
  updated_at timestamp without time zone not null default now()
);

create index if not exists idx_call_invite_target_status
  on public.call_invite(target_user_id, status, created_at desc);
create index if not exists idx_call_invite_from_status
  on public.call_invite(from_user_id, status, created_at desc);

-- 5) Backward-compatible patches
alter table public.app_user add column if not exists secret_hash varchar(255);
alter table public.app_user add column if not exists ecdh_public_key text;
alter table public.app_user add column if not exists identity_key text;
alter table public.app_user add column if not exists signed_prekey text;
alter table public.app_user add column if not exists signed_prekey_signature text;
alter table public.app_user add column if not exists registration_id integer;
alter table public.message add column if not exists ephemeral_public_key text;
alter table public.message add column if not exists ratchet_header text;
alter table public.message alter column sender_id drop not null;

-- 6) Realtime publication
do $$
begin
  alter publication supabase_realtime add table public.message;
exception
  when duplicate_object then null;
  when undefined_object then null;
end $$;

do $$
begin
  alter publication supabase_realtime add table public.friend_request;
exception
  when duplicate_object then null;
  when undefined_object then null;
end $$;

do $$
begin
  alter publication supabase_realtime add table public.call_invite;
exception
  when duplicate_object then null;
  when undefined_object then null;
end $$;

-- 7) Doctrine migration tracking
create table if not exists public.doctrine_migration_versions (
  version varchar(191) primary key,
  executed_at timestamp without time zone default null,
  execution_time integer default null
);

-- =============================================================
-- 8) SECURITY: Revoke broad permissions, enable RLS
-- =============================================================
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM anon, authenticated;
REVOKE ALL ON ALL SEQUENCES IN SCHEMA public FROM anon, authenticated;
REVOKE ALL ON ALL FUNCTIONS IN SCHEMA public FROM anon, authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON TABLES FROM anon, authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON SEQUENCES FROM anon, authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM anon, authenticated;

GRANT USAGE ON SCHEMA public TO anon, authenticated;

-- Enable and force RLS on all tables
ALTER TABLE app_user ENABLE ROW LEVEL SECURITY;
ALTER TABLE app_user FORCE ROW LEVEL SECURITY;
ALTER TABLE conversation ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation FORCE ROW LEVEL SECURITY;
ALTER TABLE conversation_member ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_member FORCE ROW LEVEL SECURITY;
ALTER TABLE message ENABLE ROW LEVEL SECURITY;
ALTER TABLE message FORCE ROW LEVEL SECURITY;
ALTER TABLE user_session ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_session FORCE ROW LEVEL SECURITY;
ALTER TABLE friend_request ENABLE ROW LEVEL SECURITY;
ALTER TABLE friend_request FORCE ROW LEVEL SECURITY;
ALTER TABLE call_invite ENABLE ROW LEVEL SECURITY;
ALTER TABLE call_invite FORCE ROW LEVEL SECURITY;
ALTER TABLE one_time_prekey ENABLE ROW LEVEL SECURITY;
ALTER TABLE one_time_prekey FORCE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'doctrine_migration_versions') THEN
    EXECUTE 'ALTER TABLE doctrine_migration_versions ENABLE ROW LEVEL SECURITY';
    EXECUTE 'ALTER TABLE doctrine_migration_versions FORCE ROW LEVEL SECURITY';
  END IF;
END $$;

-- 9) Restricted public view for user lookups (no secret_hash exposed)
CREATE OR REPLACE VIEW app_user_public AS
SELECT id, public_key, created_at
FROM app_user;

GRANT SELECT ON app_user_public TO anon, authenticated;

-- =============================================================
-- 10) RLS policies — minimal surface for Supabase anon client
-- =============================================================
-- Architecture: the frontend uses the Supabase anon key (no Supabase Auth).
-- All write operations for messages/conversations go through the backend API.
-- Supabase is used only for: realtime subscriptions, friend requests, call signaling.
-- Since there is no Supabase Auth identity (auth.uid() is null for anon),
-- row-level identity filtering is not possible. Instead we restrict the
-- allowed operations and column values to minimize abuse surface.

-- message: SELECT only. All writes go through the backend API (never via Supabase client).
-- Content is E2EE — reading ciphertext without keys reveals nothing.
GRANT SELECT ON message TO anon, authenticated;
DROP POLICY IF EXISTS message_select_policy ON message;
CREATE POLICY message_select_policy ON message FOR SELECT USING (true);
-- No INSERT/UPDATE/DELETE policy = blocked by RLS.

-- friend_request: SELECT + INSERT + UPDATE (no DELETE).
GRANT SELECT, INSERT, UPDATE ON friend_request TO anon, authenticated;
DROP POLICY IF EXISTS friend_request_select_policy ON friend_request;
DROP POLICY IF EXISTS friend_request_insert_policy ON friend_request;
DROP POLICY IF EXISTS friend_request_update_policy ON friend_request;
CREATE POLICY friend_request_select_policy ON friend_request
  FOR SELECT USING (true);
-- INSERT: only allow creating requests with 'pending' status
CREATE POLICY friend_request_insert_policy ON friend_request
  FOR INSERT WITH CHECK (
    status = 'pending'
    AND requester_id IS NOT NULL AND requester_id <> ''
    AND target_user_id IS NOT NULL AND target_user_id <> ''
    AND requester_id <> target_user_id
  );
-- UPDATE: only allow changing status to accepted/rejected (no field tampering)
CREATE POLICY friend_request_update_policy ON friend_request
  FOR UPDATE USING (true)
  WITH CHECK (status IN ('accepted', 'rejected'));

-- call_invite: SELECT + INSERT + UPDATE (no DELETE).
GRANT SELECT, INSERT, UPDATE ON call_invite TO anon, authenticated;
DROP POLICY IF EXISTS call_invite_select_policy ON call_invite;
DROP POLICY IF EXISTS call_invite_insert_policy ON call_invite;
DROP POLICY IF EXISTS call_invite_update_policy ON call_invite;
CREATE POLICY call_invite_select_policy ON call_invite
  FOR SELECT USING (true);
-- INSERT: only allow creating invites with 'pending' status
CREATE POLICY call_invite_insert_policy ON call_invite
  FOR INSERT WITH CHECK (
    status = 'pending'
    AND from_user_id IS NOT NULL AND from_user_id <> ''
    AND target_user_id IS NOT NULL AND target_user_id <> ''
    AND from_user_id <> target_user_id
  );
-- UPDATE: only allow valid status transitions
CREATE POLICY call_invite_update_policy ON call_invite
  FOR UPDATE USING (true)
  WITH CHECK (status IN ('accepted', 'rejected', 'ended'));
